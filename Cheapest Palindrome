原题链接：（POJ）
http://poj.org/problem?id=3280

题目大意：
给出一个长度为M的字符串S，给出其中字符的种类N，以及这N种字符各自的添加和删除的代价
让给出的串变成回文串的代价。

思路：
我们要有一个意识：求添加最少的字母让其回文是经典dp问题。
我们定义dp[i][j]为字符串从区间i到j变成回文的最小代价。
对于dp[i][j]有三种情况
一、
str[i]==str[j]    dp[i][j]=dp[i+1][j-1]
二、
str[i]!=str[j]
1、添加操作：dp[i][j]=min(min(dp[i][j],dfs(i+1,j)+ch[str[i]].add),dfs(i,j-1)+ch[str[j]].add);；
                                                      添加一个str[i]              添加一个str[i]
2、删除操作：dp[i][j]=min(min(dp[i][j],dfs(i+1,j)+ch[str[i]].del),dfs(i,j-1)+ch[str[j]].del);
                                                    删除一个str[i]              删除一个str[i]
这里注意改变什么下标对应的字符，那个下标不就要动，另一个不要动
 
 最终答案为dp[0][M-1]
 
 AC代码
 #include<iostream>
#include<cstring>
using namespace std;
#define inf 1000000000//取最小值，故初始化为无穷大 
#define maxn 2010

struct CH{
	int add,del;
}ch[300];

int dp[maxn][maxn];
string str;

int dfs(int i,int j)
{
	if(i>=j)
	{
		return 0;
	}
	else if(dp[i][j]!=inf)
	{
		return dp[i][j];
	}
	else if(str[i]==str[j])
	{
		return dp[i][j]=dfs(i+1,j-1);
	}
	else if(str[i]!=str[j])
	{
		//添加操作 
		dp[i][j]=min(min(dp[i][j],dfs(i+1,j)+ch[str[i]].add),dfs(i,j-1)+ch[str[j]].add);
		//删除操作 
		dp[i][j]=min(min(dp[i][j],dfs(i+1,j)+ch[str[i]].del),dfs(i,j-1)+ch[str[j]].del);
	};
	return dp[i][j];
}

int main()
{
	int N,M;
	char cha;
	cin>>N>>M>>str;
	for(int i=0;i<M;i++)
	{
		for(int j=0;j<M;j++)
		{
			dp[i][j]=inf;
		}
	}
	for(int i=1;i<=N;i++)
	{
		cin>>cha;
		cin>>ch[cha].add>>ch[cha].del;
	}
	cout<<dfs(0,M-1);
	
}
