原题链接（洛谷）
https://www.luogu.com.cn/problem/P2196

题目大意：
给出顶点数、顶点权值、顶点间的连接情况
可以从任意一个顶点出发，通向与他有连接的顶点直到无连接（有多条分支也只能选择一条）
并获得沿途经过的点的点权值
求能获得的最大权值之和以及该条最优路径的沿途顶点

分析：
一看就是和搜索有关的题
虽然这道题顶点数才20，用dfs绰绰有余
但为了入门记忆化搜索，还是放弃了暴搜过题的念头

记忆化搜索，顾名思义，会在搜索的过程中记下某些点的状态，
以便下一次又到达该点时直接使用该状态   而无需再次将为获得该状态经过的路径再走一遍
这样子的话可以减少消耗的时间

除此之外就是dfs的思想了
遍历到边界（无路可走的节点）后，将该结点状态返回
然后之前的结点的状态则借由该返回的状态更新

然后就是保存路径的问题
对于每次能更新状态的操作，就更新一下路径，用一个数组 存后继也好 存前驱也可

最后答案是取各节点能获得的权值之和的最大值

#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
#define maxn 21

int a[maxn];
int g[maxn][maxn];//存图的  
int num[maxn];//存地雷数的
int N;
int son[maxn];//存后继

int dfs(int cur){
	if(num[cur])//该结点已经搜过值了
	{
		return num[cur];
	}
	num[cur]=a[cur];//该结点还没被搜过，然后每个结点最少能获得本身的权值
	for(int i=cur+1;i<=N;i++)
	{
		if(g[cur][i])
		{
			if(dfs(i)+a[cur]>num[cur])
			{
				num[cur]=max(num[cur],dfs(i)+a[cur]);
				son[cur]=i;//更新的时候也更新路径
			}
		}
	}
	return num[cur];
}

int main()
{
	cin>>N;
	memset(son,0,sizeof(son));
	for(int i=1;i<=N;i++)
	{
		cin>>a[i]; 
	}
	for(int i=1;i<N;i++)
	{
		for(int j=i+1;j<=N;j++)
		{
			cin>>g[i][j];
		}
	}
	int MAX=0,flag;
	for(int i=1;i<=N;i++)
	{
		int temp=dfs(i);
		if(MAX<temp)
		{
			MAX=temp;
			flag=i;
		}
	}
	queue<int>q;//用了下queue解决末尾不能有多余空格的问题,实际上用cnt存路径上结点个数也可以（更好些）
	while(flag)
	{
		q.push(flag);
		flag=son[flag];
	}
	while(q.size())
	{
		cout<<q.front();
		q.pop();
		if(q.size()>=1)
		{
			cout<<" ";
		}
		else cout<<endl;
	}
	cout<<MAX<<endl;
 } 

