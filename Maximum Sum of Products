原题链接：
https://codeforces.com/problemset/problem/1519/D

题目大意：
给出两个长度为N的数组，求通过一次反转一个子连续数组使
 n
∑  a[i]⋅b[i] 最大
i=1

令dp[i][j]为反转区间为i~j的子串对于增加区间价值的贡献
反转前价值为a[l]*b[l]+a[r]*b[r]
得反转后为dp[l][r]=dfs(l+1,r-1)+a[l]*b[r]+a[r]*b[l]-a[l]*b[l]-a[r]*b[r]
                  //状态转移
               n   
最后再用原本的 ∑  a[i]⋅b[i]加上dp[1][len]即可得到答案
               i=1
               
AC代码
#include<iostream>
#include<cstring>
using namespace std;
#define maxn 5001

long long dp[maxn][maxn],a[maxn],b[maxn];//题目数据有点大，我习惯全部都开longlong

long long dfs(int l,int r)
{
	if(l>=r)
	{
		return 0;
	}
	if(dp[l][r]!=-1)
	{
		return dp[l][r];
	}
	dp[l][r]=dfs(l+1,r-1)+a[l]*b[r]+a[r]*b[l]-a[l]*b[l]-a[r]*b[r];
	return dp[l][r];
}

int main()
{
	long long N;
	memset(dp,-1,sizeof dp);
	cin>>N;
	for(long long i=1;i<=N;i++)
	{
		cin>>a[i];
	}
	long long sum=0;
	for(long long i=1;i<=N;i++)
	{
		cin>>b[i];
		sum+=a[i]*b[i];
	}
	long long ans=-10000000;
	for(long long i=1;i<=N;i++)
	for(long long j=1;j<=N;j++)
	{
		ans=max(ans,dfs(i,j));
	}
	cout<<ans+sum<<endl;
}
 
