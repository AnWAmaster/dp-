原题链接(洛谷)
https://www.luogu.com.cn/problem/P1616

大致题意：
给出可用总时间和草药的数目
给出每种草药的采集时间和价值
每种草药可无限制采
求规定的时间内，可以采到的草药的最大总价值。

思路：
典型的完全背包题（每种物品数量无限）

我一开始做了下尝试：
三重循环---第一层遍历草药，第二层遍历该种草药拿几个，第三层遍历可用时间
然后最后一个样例TLE了，于是去学习多重背包的状态转移方程

对于我一开始的尝试，(这里先令第i种草药的花费时间为t，价值为v)
为dp[i][j]=max(dp[i-1][j],dp[i-1][j-t]+v,dp[i-1][j-2*t]+2*v,......,dp[i-1][j-k*t]+k*v);

然而我们可以发现
dp[i][j-t]+v=max(dp[i-1][j-t]+v,dp[i-1][j-2*t]+2*v,dp[i-1][j-3*t]+3*v,......,dp[i-1][j-k*t]+k*v);(注意最后一项还是j-k*t,不是j-(k+1)*t)

把这个式子往上面代就得到了dp[i][[j]=max(dp[i-1][j],dp[i][j-t]);
于是便很巧妙的得到了完全背包的状态转移方程,其中[i-1][j]和[i][j-t]均在[i][j]前面，所以第二层用正序遍历即可

看到状态转移中dp[i]只与dp[i]和dp[i-1]有关，故又可以考虑dp数组一维优化

我们知道一维优化都是基于二维的，我们只是在二维的基础上去掉了一个维度，新的一维数组应该在逻辑上能还原为二维

去掉第一维后，得dp[j]=max(dp[j],dp[j-t]);
我们把这个取最值的部分分成两部分
1、dp[j]=dp[j]   这个在代码上看起来毫无意义，实际上还原为二维后为dp[i][j]=dp[i-1][j],
                  即对于dp[j]=dp[j],即左值为新的dp数，右值为之前已计算过的dp数
2、dp[j]=dp[j-t]  这个还好理解，毕竟还原为二维后第一维都是相同的

然后因为使用过01背包一维优化，我们此时也会冒出一个同样的疑问：第二层循环应该是正序还是逆序？

我们看下01背包
dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+val[i])--->
dp[j]=max(dp[j],dp[j-v[i]]+val[i])
如果二层循环正序，实际上dp[j-v[i]]还原后应为dp[i][j-v[i]]，出现了问题
而倒序可以保证dp[j-v[i]]会在dp[j]之后更新，从而保证当前状态利用的均是上一层的而不是同一层的状态

而对于完全背包
我们从01背包中发现导致逆序的主要元凶是dp[j-v[i]]--->dp[i-1][j-v[i]]
然而完全背包的状态转移方程dp[i][[j]=max(dp[i-1][j],dp[i][j-t])并不存在该种元凶,dp[i][j-t]利用的也是当前层的状态
所以我们可以放心的使用正序循环

AC代码如下

#include<iostream>
#include<cstdio>
using namespace std;

typedef long long ll;//有部分样例数据范围超出int了

struct yao{
	ll val,time;
}y[10001];

ll dp[10000001];//1e7，能开

int main()
{
	ll totaltime,num;
	scanf("%lld%lld",&totaltime,&num);
	for(ll i=1;i<=num;i++)
	{
		scanf("%lld%lld",&y[i].time,&y[i].val);
	}
	for(ll i=1;i<=num;i++)
	{
		for(ll j=y[i].time;j<=totaltime;j++)
		{
			dp[j]=max(dp[j],dp[j-y[i].time]+y[i].val);
		}
	}
	cout<<dp[totaltime]<<endl;
 }




