原题链接
https://codeforces.com/contest/1521/problem/B

大致题意：
给出T个样例
对于每个样例给出数组大小N，接着给出N个数组元素（正整数）

题目给出了一个定义：如果对于所有的下标i(i>=2&&i<=N),都有a[i]和a[i-1]互质，则该数组为好数组
题目还给出了一种操作：可以挑选两个不同的下标i和j，与两个整数x和y（x和y在范围内任取）,在min(a[i],a[j])==min(x,y)的前提下可以将a[i]变为x, 将a[j]变为y
题目要让我们在最多N次该种操作下将题给数组变为好数组（必定可行）

输出格式为
第一行  操作次数K次
下面的K行：每行对应该次操作的i,j,x,y

数据范围为   1<=N&&N<=1e5   1<=a[i]&&a[i]<=1e9

然后两个非常重要的题意：
1、如果有多种答案，输出任意一个
2、不需要追求操作次数K最小（！！！）

思路：
输出任意一个答案，这说明本题绝对有规律可循，是个思维题
仔细想想就能发现，对于操作的前提min(a[i],a[j])==min(x,y)
如果我们始终把数组中最小值作为a[i]，其他数依次放在a[j]的位置，同时还让x的值一直为数组最小值
那么该前提始终成立，且数组最小值永不变化，并且总能让a[j]被y替代

这样子就可以在N-1次操作下变换数组元素了（因为不需要最小化K，故可以放手去操作了）

那么还要考虑“好数组”的问题
我们现在已经有能力变换除数组最小元素以外的元素了
于是可以考虑让被变换的元素都变为质数（质数总与质数互质）

并且该质数不能都为同一个（相同的两数的gcd为该数本身）
并且变换成的质数不能是数组最小值的因数

考虑数组元素最大为1e9
故找质数1e9+7和1e9+9作为替代数，根据下标的奇偶轮流替换a[j]

于是遍历数组，遇到最小值元素就continue，否则就输出该次操作涉及的元素即可

AC代码
#include<iostream>
using namespace std;
#define maxn 300000
#define inf 1000000007
#define INF 1000000009

int a[maxn];

int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		int N,MIN,flag;
		MIN=inf;
		cin>>N;
		for(int i=1;i<=N;i++)
		{
			cin>>a[i];
			if(MIN>a[i])
			{
				flag=i;
				MIN=a[i];//打擂台找最小值 
			}
		}
		cout<<N-1<<endl;//直接输出 
		for(int i=1;i<=N;i++)
		{
			if(i==flag)
			{
				continue;
			}
			//根据奇偶轮流选用INF和inf 
			if(i&1)
			{
				cout<<i<<" "<<flag<<" "<<INF<<" "<<a[flag]<<endl;
			}
			else cout<<i<<" "<<flag<<" "<<inf<<" "<<a[flag]<<endl;
		}
	}
 } 









